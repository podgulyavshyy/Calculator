static double Evaluate(string input)
    {
        // remove whitespace from input
        input = input.Replace(" ", "");

        // initialize stacks for operators and operands
        Stack<char> operatorStack = new Stack<char>();
        Stack<double> operandStack = new Stack<double>();

        // shunting yard algorithm - convert infix notation to postfix notation
        for (int i = 0; i < input.Length; i++)
        {
            char c = input[i];

            if (c >= '0' && c <= '9')
            {
                // digit - push onto operand stack
                double operand = 0;
                int decimalCount = 0;
                while (i < input.Length && ((input[i] >= '0' && input[i] <= '9') || input[i] == '.'))
                {
                    if (input[i] == '.')
                    {
                        decimalCount++;
                    }
                    else
                    {
                        operand = operand * 10 + (input[i] - '0');
                        if (decimalCount > 0)
                        {
                            decimalCount++;
                        }
                    }

                    i++;
                }

                operand /= Math.Pow(10, decimalCount);
                operandStack.Push(operand);
                i--; // backtrack one character to account for the last character in the operand
            }
            else if (c == '(')
            {
                // left parenthesis - push onto operator stack
                operatorStack.Push(c);
            }
            else if (c == ')')
            {
                // right parenthesis - pop operators and operands until the corresponding left parenthesis is found
                while (operatorStack.Count > 0 && operatorStack.Peek() != '(')
                {
                    double rightOperand = operandStack.Pop();
                    double leftOperand = operandStack.Pop();
                    char op = operatorStack.Pop();
                    double result = ApplyOperator(op, leftOperand, rightOperand);
                    operandStack.Push(result);
                }

                operatorStack.Pop(); // discard the left parenthesis
            }
            else if (c == '+' || c == '-' || c == '*' || c == '/')
            {
                // operator - pop operators and operands until the operator stack is empty or the top operator has lower precedence than the current operator, then push the current operator onto the stack
                while (operatorStack.Count > 0 && Precedence(operatorStack.Peek()) >= Precedence(c))
                {
                    double rightOperand = operandStack.Pop();
                    double leftOperand = operandStack.Pop();
                    char op = operatorStack.Pop();
                    double result = ApplyOperator(op, leftOperand, rightOperand);
                    operandStack.Push(result);
                }

                operatorStack.Push(c);
            }
            else
            {
                throw new ArgumentException("Invalid character: " + c);
            }
        }


        // pop any remaining operators and operands and evaluate the expression
        while (operatorStack.Count > 0)
        {
            double rightOperand = operandStack.Pop();
            double leftOperand = operandStack.Pop();
            char op = operatorStack.Pop();
            double result = ApplyOperator(op, leftOperand, rightOperand);
            operandStack.Push(result);
        }

        // the final result is the top value on the operand stack
        if (operandStack.Count == 1)
        {
            return operandStack.Pop();
        }
        else
        {
            throw new ArgumentException("Invalid expression.");
        }
    }

    static int Precedence(char op)
    {
        switch (op)
        {
            case '+':
            case '-':
                return 1;
            case '*':
            case '/':
                return 2;
            default:
                throw new ArgumentException("Invalid operator: " + op);
        }
    }

    static double ApplyOperator(char op, double leftOperand, double rightOperand)
    {
        switch (op)
        {
            case '+':
                return leftOperand + rightOperand;
            case '-':
                return leftOperand - rightOperand;
            case '*':
                return leftOperand * rightOperand;
            case '/':
                if (rightOperand == 0)
                {
                    throw new ArgumentException("Division by zero.");
                }

                return leftOperand / rightOperand;
            default:
                throw new ArgumentException("Invalid operator: " + op);
        }
    }
}